[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to gridstitcher",
    "section": "",
    "text": "Some camera systems, such as infrared reflectography at 1600nm, inherently produce fairly low resolution images. To increase overall image resolution it is possible to photograph an object in parts in a regular grid of overlapping image tiles. This then leaves us with the task of stitching or registering those tiles into a composite image. Doing this manually with a photo editor is certainly possible. However for large amounts of images this becomes a time consuming and tedious job.\nIn the recent Falnama project with Wereldmuseum and Klassik Stiftung Weimar we acquired 36 image tiles for 35 pages each. So we needed an automated stitching software. After unsuccessful trials for our types of images with Photoshop and several existing Python packages our project team decided to try and develop our own open source Python package gridstitcher.\nIf you are interested you can install the package from the Python package soon. You can also study the github source code and the documentation.",
    "crumbs": [
      "Welcome to gridstitcher"
    ]
  },
  {
    "objectID": "automated-tile-grid-stitching-how-it-works.html",
    "href": "automated-tile-grid-stitching-how-it-works.html",
    "title": "Automated tile grid stitching - how it works",
    "section": "",
    "text": "You can find a lot of tutorials how to do simple image stitching using two photos and that is no problem. But what to do when I want to make a panorama from 4-6 images or more?\nThis question posted on stackoverflow, this article, make clear that robust automated stitching of multiple images presents a much harder problem. In case you are interested to learn how this works. Here follows a brief description of the consecutive steps of automated tile stitching algorithm implemented in gridstitcher.\nTo get started you need to obtain a list of the tile image files. This is best done with the operating system independent standard package pathlib. Let’s also already import matplotlib here to inspect the result below.\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\ntiles_dir = Path('/home/frank/Work/Werknummers/2024-811_Falnama/data/Weimar-IRR_1600nm/71803-02_IRR 1600 nm/') \nim_files = sorted(tiles_dir.glob('*.tif'))\nlen(im_files)\n\n36\nTo perform the consecutive steps of the automated registration of the image tiles we first need to import the Tilegrid class.\nfrom gridstitcher import Tilegrid\nTile registration is performed in three consecutive steps. In step 1 we instantiate a Tilegrid object with a sorted list of image files, and specify the number of rows and columns for the grid.\ntg = Tilegrid(im_files, nrows=6, ncols=6) # 1) load images\n\nInitializing regular 6x6 tile grid...\nIn step 2 the SIFT-RANSAC algorithm is used to obtain pairs of points that match corresponding features on adjacent tiles. These point pairs are computed and plotted with the Tilegrid.get_ransac_pair_points() method.\ntg.get_ransac_pair_points()\n\nDetecting corresponding SIFT RANSAC point pairs...\nCould not detect corresponding feature points in tile pair [2, 3] \nCould not detect corresponding feature points in tile pair [3, 4]\nFor this specific example warnings are given that in the tile overlap pairs [2, 3] and [3, 4] no corresponding feature points were detected. The absence of overlap pair is not a problem as long as each tile is connected at least with one other tile.\nIn step 3 the sum of distances for all RANSAC point pairs in the tile grid is minimized by shifting each individual tile left-right and up-down. Note that we do not rotate, scale or warp the images.\ntg.register_tiles()                          # 3) shift tiles to optimal overlap\n\nRegistering tiles...\nSum of tile distances: 4536.0       \n\n\n/home/frank/anaconda3/lib/python3.11/site-packages/scipy/optimize/_minimize.py:705: OptimizeWarning: Desired error not necessarily achieved due to precision loss.\n  res = _minimize_bfgs(fun, x0, args, jac, callback, **options)\n\n\n         Current function value: 4536.434504\n         Iterations: 115\n         Function evaluations: 15487\n         Gradient evaluations: 212\nIn our example we observe that the registration of the individual tiles is successful. To make the composite image array use the method Tilegrid.make_stitched(). If you specify the option save_to= you can automatically save to an image file.\nstitched_im = tg.make_stitched(save_to='../downloads/stitched.png')\n\nSaving image to: ../downloads/stitched.png\nLet’s inspect our stitched mosaic image.\nfig, ax = plt.subplots()\nax.imshow(stitched_im)\nNicely registered!",
    "crumbs": [
      "Automated tile grid stitching - how it works"
    ]
  },
  {
    "objectID": "automated-tile-grid-stitching-how-it-works.html#functions",
    "href": "automated-tile-grid-stitching-how-it-works.html#functions",
    "title": "Automated tile grid stitching - how it works",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nmake_stitched\n\n make_stitched (ims, extent_list, save_to=None)\n\n*Create a stitched mosaic image from tile images ims and tile positions extent_list.\nReturns: stitched_im*\n\nsource\n\n\nremove_outliers\n\n remove_outliers (rpp_list, oip_list, nrows, ncols, max_delta=20,\n                  verbose=True)\n\nRemove vector outliers from rpp and oip lists based on max_delta pixels shift.\n\nsource\n\n\ncrop\n\n crop (ax, extent_list)\n\n\nsource\n\n\nplot_vectors\n\n plot_vectors (canvas_rpp_list, oip_list, ax)\n\nPlot vectors from canvas_rpp_list on active canvas ax with overlapping image pair list oip_list.\n\nsource\n\n\ntotal_distance\n\n total_distance (b_flat, rpp_list, oip_list)\n\nCompute distances.\n\nsource\n\n\nget_canvas_rpp_list\n\n get_canvas_rpp_list (rpp_list, oip_list, b_flat)\n\nCompute canvas positions of red and green points.\n\nsource\n\n\nget_extent_list\n\n get_extent_list (b_flat, tile_h, tile_w)\n\n*Compute tile images extents on canvas.\nextent : left, right, bottom, top*\n\nsource\n\n\nget_x0_list\n\n get_x0_list (nrows, ncols, tile_h, tile_w, margin=20)\n\nInitial flat tile positions list.\n\nsource\n\n\nadd_ransac_markers\n\n add_ransac_markers (axs, oips, ransac_points_pair_list)\n\nAdd red and green markers for corresponding points in all tiles.\n\nsource\n\n\nget_ransac_pair_points\n\n get_ransac_pair_points (oips, kpts_descr_list)\n\n\nsource\n\n\nmake_overlap_image_pairs\n\n make_overlap_image_pairs (nrows, ncols)\n\nGenerate image pair indices for horizontal and vertical overlap pairs.\n\nsource\n\n\nmake_kpts_descr_list\n\n make_kpts_descr_list (ims)\n\nCreate keypoints and descriptors list for al images ims.\n\nsource\n\n\nTilegrid\n\n Tilegrid (im_files, nrows, ncols, filenames=True, tile_borders=True)\n\nCreate a Tilegrid object.",
    "crumbs": [
      "Automated tile grid stitching - how it works"
    ]
  }
]